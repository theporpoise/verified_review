var assert = require('assert')
var async = require('async')
var request = require('superagent')
var utils = require('./utils')

function Addresses(url) {
  this.url = url
}

Addresses.prototype.summary = function(addresses, done) {
  var base = this.url + '?addresses='
  var queries = utils.paginate(base, '&addresses=', 50, null, [].concat(addresses))

  var tasks = queries.map(function(query) {
    return function(callback) {
      request
      .get(query)
      .end(utils.handleJSend(function(data) {
        return data.addresses.map(function(address) {
          return {
            address: address.address,
            balance: address.balance,
            totalReceived: address.totalReceivedValue,
            txCount: address.txsCount
          }
        })
      }, callback))
    }
  })

  async.parallel(tasks, function(err, results) {
    if (err) return done(err)

    // flatten results
    results = [].concat.apply([], results)

    done(undefined, Array.isArray(addresses) ? results : results[0])
  })
}

Addresses.prototype.transactions = function(addresses, blockHeight, done) {
  // optional blockHeight
  if ('function' === typeof blockHeight) {
    done = blockHeight
    blockHeight = 0
  }

  var base = this.url + '/transactions?addresses='
  var queries = utils.paginate(base, '&addresses=', 50, 1e4, [].concat(addresses))

  var tasks = queries.map(function(query) {
    return function(callback) {
      request
      .get(query)
      .end(utils.handleJSend(function(data) {
        return data.transactions.filter(function(tx) {
          return tx.blockHeight >= blockHeight
        }).map(function(tx) {
          return {
            txId: tx.txHash,
            txHex: utils.parseHBTransaction(tx),
            blockId: tx.blockHash,
            blockHeight: tx.blockHeight
          }
        })
      }, callback))
    }
  })

  async.parallel(tasks, function(err, results) {
    if (err) return done(err)

    // flatten results
    results = [].concat.apply([], results)

    done(undefined, results)
  })
}

Addresses.prototype.unspents = function(addresses, done) {
  var base = this.url + '/unspents?addresses='
  var queries = utils.paginate(base, '&addresses=', 50, 1e4, [].concat(addresses))

  var tasks = queries.map(function(query) {
    return function(callback) {
      request
      .get(query)
      .end(utils.handleJSend(function(data) {
        return data.unspents.filter(function(unspent) {
          return unspent.type === 'pubkeyhash' || unspent.type === 'scripthash'
        }).map(function(unspent) {
          return {
            txId: unspent.txHash,
            address: unspent.address,
            confirmations: unspent.confirmations,
            value: unspent.value,
            vout: unspent.index
          }
        })
      }, callback))
    }
  })

  async.parallel(tasks, function(err, results) {
    if (err) return done(err)

    // flatten results
    results = [].concat.apply([], results)

    done(undefined, results)
  })
}

Addresses.prototype.__faucetWithdraw = function(address, value, callback) {
  assert(/testnet/.test(this.url), 'Network must be testnet')

  request
  .post('https://testnet.helloblock.io/v1/faucet/withdrawal')
  .send({
    toAddress: address,
    value: value
  })
  .end(function(err, res) {
    if (err) return callback(err)

    return callback()
  })
}

module.exports = Addresses
